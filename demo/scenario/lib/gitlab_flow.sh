#!/bin/bash
# GitLab Flow Library for AITL Demo
# Provides GitLab issue/branch/MR management functions
#
# This library is sourced by demo.sh and provides:
#   - GitLab issue creation (linked to Jira)
#   - Branch creation and push
#   - MR creation and merge handling (auto + HITL fallback)
#
# Prerequisites:
#   - glab CLI authenticated
#   - DEMO_WORKSPACE set to a git repository

# Ensure workspace is set
: "${DEMO_WORKSPACE:=/tmp/aitl-demo}"
: "${DEMO_RUN_ID:=$(date +%Y%m%d-%H%M%S)}"

# GitLab issue labels
readonly LABEL_DEMO="aitl-demo"
readonly LABEL_HOTFIX="hotfix"
readonly LABEL_FEATURE="feature"

# Create GitLab issue linked to Jira task
# Args: $1=jira_key, $2=summary, $3=issue_type (feat|hotfix)
# Returns: GitLab issue IID via stdout
gitlab_issue_create_for_jira() {
	local jira_key="$1"
	local summary="$2"
	local issue_type="${3:-feat}"

	if [[ -z "${jira_key}" ]] || [[ -z "${summary}" ]]; then
		log_error "Usage: gitlab_issue_create_for_jira <jira_key> <summary> [issue_type]"
		return 1
	fi

	local jira_url="${JIRA_BASE_URL}/browse/${jira_key}"
	local labels="${LABEL_DEMO}"

	case "${issue_type}" in
		hotfix)
			labels="${labels},${LABEL_HOTFIX}"
			;;
		feat|feature)
			labels="${labels},${LABEL_FEATURE}"
			;;
	esac

	local description="## Jira Link

- Jira Issue: [${jira_key}](${jira_url})

## Description

${summary}

---
*Auto-generated by AITL Demo (Run ID: ${DEMO_RUN_ID})*"

	log_info "Creating GitLab issue for ${jira_key}..."

	local result
	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would create GitLab issue: [${jira_key}] ${summary}"
		echo "999"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	result=$(glab issue create \
		--title "[${jira_key}] ${summary}" \
		--description "${description}" \
		--label "${labels}" \
		2>&1)

	local issue_url
	issue_url=$(echo "${result}" | grep -oE 'https://[^[:space:]]+/issues/[0-9]+' | head -1)

	if [[ -z "${issue_url}" ]]; then
		log_error "Failed to create GitLab issue"
		echo "${result}" >&2
		return 1
	fi

	local issue_iid
	issue_iid=$(echo "${issue_url}" | grep -oE '[0-9]+$')

	log_ok "Created GitLab issue #${issue_iid}: ${issue_url}"
	echo "${issue_iid}"
}

# Create branch and push initial commit
# Args: $1=jira_key, $2=branch_type (feat|hotfix), $3=summary
# Returns: branch name via stdout
gitlab_branch_create_and_push() {
	local jira_key="$1"
	local branch_type="${2:-feat}"
	local summary="$3"

	if [[ -z "${jira_key}" ]]; then
		log_error "Usage: gitlab_branch_create_and_push <jira_key> [branch_type] [summary]"
		return 1
	fi

	# Generate branch name
	local slug
	if [[ -n "${summary}" ]]; then
		slug=$(echo "${summary}" | \
			tr '[:upper:]' '[:lower:]' | \
			tr ' ' '-' | \
			tr -cd '[:alnum:]-' | \
			cut -c1-30 | \
			sed 's/-$//')
	else
		slug="task"
	fi

	local branch_name="${branch_type}/${jira_key}-${DEMO_RUN_ID}-${slug}"

	log_info "Creating branch: ${branch_name}"

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would create branch: ${branch_name}"
		log_info "[DRY-RUN] Would create worklog file and push"
		echo "${branch_name}"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	# Ensure we're on main/master
	local default_branch
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
	default_branch="${default_branch:-main}"

	git checkout "${default_branch}" >/dev/null 2>&1 || git checkout -b "${default_branch}" >/dev/null 2>&1
	git pull origin "${default_branch}" >/dev/null 2>&1 || true

	# Create branch
	if git checkout -b "${branch_name}" >/dev/null 2>&1; then
		log_ok "Branch created: ${branch_name}" >&2
	else
		log_warn "Branch may already exist, checking out..." >&2
		git checkout "${branch_name}" >/dev/null 2>&1 || return 1
	fi

	# Create worklog file as "trace" of work
	local worklog_dir="${DEMO_WORKSPACE}/worklog"
	mkdir -p "${worklog_dir}"

	local worklog_file="${worklog_dir}/${jira_key}.md"
	local timestamp
	timestamp=$(date '+%Y-%m-%d %H:%M:%S')

	cat > "${worklog_file}" <<EOF
# Work Log: ${jira_key}

## Summary
${summary:-Task work log}

## Timeline

- **Started**: ${timestamp}
- **Branch**: ${branch_name}
- **Run ID**: ${DEMO_RUN_ID}

## Notes

This file was auto-generated by AITL Demo to track work on ${jira_key}.

---
*Generated at ${timestamp}*
EOF

	# Create minimal C artifact for sample comparison
	local src_dir="${DEMO_WORKSPACE}/src"
	mkdir -p "${src_dir}"
	local c_file="${src_dir}/${jira_key}.c"
	cat > "${c_file}" <<EOF
/*
 * ${jira_key}: ${summary:-Demo task}
 */

int ${jira_key//-/_}_placeholder(void) {
	return 0;
}
EOF

	# Commit and push
	git add "${worklog_file}" "${c_file}" >/dev/null 2>&1
	git commit -m "${branch_type}: [${jira_key}] ${summary:-work in progress}

Jira: ${jira_key}
Run-ID: ${DEMO_RUN_ID}" >/dev/null 2>&1

	if git push -u origin "${branch_name}" >/dev/null 2>&1; then
		log_ok "Branch pushed: ${branch_name}" >&2
	else
		log_error "Failed to push branch" >&2
		return 1
	fi

	echo "${branch_name}"
}

# Create Merge Request
# Args: $1=branch_name, $2=jira_key, $3=gitlab_issue_iid, $4=summary
# Returns: MR IID via stdout
gitlab_mr_create() {
	local branch_name="$1"
	local jira_key="$2"
	local gitlab_issue_iid="$3"
	local summary="$4"

	if [[ -z "${branch_name}" ]] || [[ -z "${jira_key}" ]]; then
		log_error "Usage: gitlab_mr_create <branch_name> <jira_key> [gitlab_issue_iid] [summary]"
		return 1
	fi

	local jira_url="${JIRA_BASE_URL}/browse/${jira_key}"

	local description="## Summary

${summary:-Work completed for ${jira_key}}

## Jira Link

- [${jira_key}](${jira_url})
"

	# Add GitLab issue close reference if provided
	if [[ -n "${gitlab_issue_iid}" ]]; then
		description+="
## Related Issues

Closes #${gitlab_issue_iid}
"
	fi

	description+="
---
*Auto-generated by AITL Demo (Run ID: ${DEMO_RUN_ID})*"

	log_info "Creating MR for ${jira_key}..."

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would create MR: [${jira_key}] ${summary}"
		echo "999"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	local result
	result=$(glab mr create \
		--title "[${jira_key}] ${summary:-Task completion}" \
		--description "${description}" \
		--source-branch "${branch_name}" \
		--remove-source-branch \
		--yes \
		2>&1)

	local mr_url
	mr_url=$(echo "${result}" | grep -oE 'https://[^[:space:]]+/merge_requests/[0-9]+' | head -1)

	if [[ -z "${mr_url}" ]]; then
		log_error "Failed to create MR"
		echo "${result}" >&2
		return 1
	fi

	local mr_iid
	mr_iid=$(echo "${mr_url}" | grep -oE '[0-9]+$')

	log_ok "Created MR !${mr_iid}: ${mr_url}"
	echo "${mr_iid}"
}

# Wait for MR to be merged (auto-merge attempt + HITL fallback)
# Args: $1=mr_iid, $2=hitl_enabled (true|false)
# Returns: 0 if merged, 1 if failed/cancelled
gitlab_mr_wait_merge() {
	local mr_iid="$1"
	local hitl_enabled="${2:-false}"
	local max_attempts="${3:-3}"

	if [[ -z "${mr_iid}" ]]; then
		log_error "Usage: gitlab_mr_wait_merge <mr_iid> [hitl_enabled] [max_attempts]"
		return 1
	fi

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would wait for MR !${mr_iid} to be merged"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	log_info "Checking MR !${mr_iid} status..."

	# Check current MR status
	local mr_status
	mr_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.state // "unknown"')

	if [[ "${mr_status}" == "merged" ]]; then
		log_ok "MR !${mr_iid} is already merged"
		return 0
	fi

	if [[ "${mr_status}" == "closed" ]]; then
		log_error "MR !${mr_iid} is closed (not merged)"
		return 1
	fi

	# Try auto-merge
	log_info "Attempting to merge MR !${mr_iid}..."

	local attempt=1
	while [[ ${attempt} -le ${max_attempts} ]]; do
		log_info "Merge attempt ${attempt}/${max_attempts}..."

		if glab mr merge "${mr_iid}" --yes 2>/dev/null; then
			log_ok "MR !${mr_iid} merged successfully"
			return 0
		fi

		# Check if it needs approval or has other blockers
		local merge_status
		merge_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.detailed_merge_status // .merge_status // "unknown"')

		case "${merge_status}" in
			"mergeable"|"can_be_merged")
				# Should be mergeable, retry
				sleep 2
				;;
			"not_approved"|"need_approval"|"approvals_syncing")
				log_warn "MR requires approval"
				break
				;;
			"blocked_status"|"discussions_not_resolved")
				log_warn "MR has unresolved discussions or is blocked"
				break
				;;
			"checking"|"unchecked")
				log_info "MR is being checked, waiting..."
				sleep 5
				;;
			*)
				log_warn "MR status: ${merge_status}"
				break
				;;
		esac

		((attempt++))
	done

	# Auto-merge failed, try HITL if enabled
	if [[ "${hitl_enabled}" == "true" ]]; then
		local mr_url
		mr_url=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.web_url')

		log_warn "HITL: Auto-merge failed for MR !${mr_iid}"
		log_info "Please manually approve/merge the MR:"
		log_info "  ${mr_url}"
		echo ""
		log_info "Press Enter after merging the MR (or type 'skip' to skip)..."

		local response
		read -r response

		if [[ "${response}" == "skip" ]]; then
			log_warn "MR merge skipped by user"
			return 1
		fi

		# Verify merge
		mr_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.state // "unknown"')

		if [[ "${mr_status}" == "merged" ]]; then
			log_ok "MR !${mr_iid} confirmed merged"
			return 0
		else
			log_error "MR !${mr_iid} is still not merged (status: ${mr_status})"
			return 1
		fi
	fi

	log_error "Could not merge MR !${mr_iid}"
	return 1
}

# Check if MR is merged
# Args: $1=mr_iid
# Returns: 0 if merged, 1 if not
gitlab_mr_is_merged() {
	local mr_iid="$1"

	if [[ -z "${mr_iid}" ]]; then
		return 1
	fi

	if [[ "${DRY_RUN}" == "true" ]]; then
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	local mr_status
	mr_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.state // "unknown"')

	[[ "${mr_status}" == "merged" ]]
}

# Get MR URL
# Args: $1=mr_iid
# Returns: MR URL via stdout
gitlab_mr_get_url() {
	local mr_iid="$1"

	if [[ -z "${mr_iid}" ]]; then
		return 1
	fi

	if [[ "${DRY_RUN}" == "true" ]]; then
		echo "https://gitlab.example.com/demo/merge_requests/${mr_iid}"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.web_url'
}

# Add trace comment to Jira issue
# Args: $1=jira_key, $2=mr_url, $3=branch_name, $4=gitlab_issue_iid
jira_add_gitlab_trace() {
	local jira_key="$1"
	local mr_url="$2"
	local branch_name="$3"
	local gitlab_issue_iid="$4"

	if [[ -z "${jira_key}" ]]; then
		return 1
	fi

	# Construct comment text
	local comment="GitLab Integration (Run: ${DEMO_RUN_ID})
- MR: ${mr_url:-N/A}
- Branch: ${branch_name:-N/A}
- GitLab Issue: #${gitlab_issue_iid:-N/A}
- Status: MR Merged"

	log_info "Adding GitLab trace comment to ${jira_key}..."

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would add comment to ${jira_key}"
		return 0
	fi

	local pm_cmd="${PM_CMD:-${PROJECT_ROOT}/tools/pm/bin/pm}"

	if ${pm_cmd} jira issue comment add "${jira_key}" "${comment}" 2>/dev/null; then
		log_ok "GitLab trace added to ${jira_key}"
		return 0
	else
		log_warn "Could not add GitLab trace comment to ${jira_key}"
		return 1
	fi
}

# Full GitLab flow: issue -> branch -> commit -> MR -> merge
# Args: $1=jira_key, $2=summary, $3=issue_type (feat|hotfix), $4=hitl_enabled
# Returns: 0 if successful (MR merged), 1 if failed
gitlab_full_flow() {
	local jira_key="$1"
	local summary="$2"
	local issue_type="${3:-feat}"
	local hitl_enabled="${4:-false}"

	if [[ -z "${jira_key}" ]]; then
		log_error "Usage: gitlab_full_flow <jira_key> [summary] [issue_type] [hitl_enabled]"
		return 1
	fi

	log_info "Starting GitLab flow for ${jira_key}..."

	# Step 1: Create GitLab issue
	local gitlab_issue_iid
	gitlab_issue_iid=$(gitlab_issue_create_for_jira "${jira_key}" "${summary}" "${issue_type}")

	if [[ -z "${gitlab_issue_iid}" ]]; then
		log_error "Failed to create GitLab issue"
		return 1
	fi

	# Step 2: Create branch and push
	local branch_name
	branch_name=$(gitlab_branch_create_and_push "${jira_key}" "${issue_type}" "${summary}")

	if [[ -z "${branch_name}" ]]; then
		log_error "Failed to create branch"
		return 1
	fi

	# Step 3: Create MR
	local mr_iid
	mr_iid=$(gitlab_mr_create "${branch_name}" "${jira_key}" "${gitlab_issue_iid}" "${summary}")

	if [[ -z "${mr_iid}" ]]; then
		log_error "Failed to create MR"
		return 1
	fi

	# Step 4: Wait for merge
	if gitlab_mr_wait_merge "${mr_iid}" "${hitl_enabled}"; then
		log_ok "GitLab flow completed for ${jira_key}"

		# Store MR info for later use
		GITLAB_LAST_MR_IID="${mr_iid}"
		GITLAB_LAST_MR_URL=$(gitlab_mr_get_url "${mr_iid}")
		GITLAB_LAST_ISSUE_IID="${gitlab_issue_iid}"
		GITLAB_LAST_BRANCH="${branch_name}"

		# Step 5: Add trace comment to Jira
		jira_add_gitlab_trace "${jira_key}" "${GITLAB_LAST_MR_URL}" "${branch_name}" "${gitlab_issue_iid}"

		return 0
	else
		log_warn "GitLab flow incomplete for ${jira_key} (MR not merged)"
		return 1
	fi
}

# Export functions
export -f gitlab_issue_create_for_jira
export -f gitlab_branch_create_and_push
export -f gitlab_mr_create
export -f gitlab_mr_wait_merge
export -f gitlab_mr_is_merged
export -f gitlab_mr_get_url
export -f gitlab_full_flow
export -f jira_add_gitlab_trace

# Export state variables
export GITLAB_LAST_MR_IID
export GITLAB_LAST_MR_URL
export GITLAB_LAST_ISSUE_IID
export GITLAB_LAST_BRANCH
