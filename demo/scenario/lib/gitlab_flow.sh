#!/bin/bash
# GitLab Flow Library for AITL Demo
# Provides GitLab issue/branch/MR management functions
#
# This library is sourced by demo.sh and provides:
#   - GitLab issue creation (linked to Jira)
#   - Branch creation and push
#   - MR creation and merge handling (auto + HITL fallback)
#
# Prerequisites:
#   - glab CLI authenticated
#   - DEMO_WORKSPACE set to a git repository

# DEMO_WORKSPACE and DEMO_REPO_NAME must be set by caller (demo.sh)
# Do NOT set default values here - it causes silent failures when GitLab setup fails

# GitLab issue labels
readonly LABEL_DEMO="aitl-demo"
readonly LABEL_HOTFIX="hotfix"
readonly LABEL_FEATURE="feature"

# Create GitLab issue linked to Jira task
# Args: $1=jira_key, $2=summary, $3=issue_type (feat|hotfix)
# Returns: GitLab issue IID via stdout
gitlab_issue_create_for_jira() {
	local jira_key="$1"
	local summary="$2"
	local issue_type="${3:-feat}"

	if [[ -z "${jira_key}" ]] || [[ -z "${summary}" ]]; then
		log_error "Usage: gitlab_issue_create_for_jira <jira_key> <summary> [issue_type]"
		return 1
	fi

	local jira_url="${JIRA_BASE_URL}/browse/${jira_key}"
	local labels="${LABEL_DEMO}"

	case "${issue_type}" in
		hotfix)
			labels="${labels},${LABEL_HOTFIX}"
			;;
		feat|feature)
			labels="${labels},${LABEL_FEATURE}"
			;;
	esac

	local description="## Jira Link

- Jira Issue: [${jira_key}](${jira_url})

## Description

${summary}

---
*Auto-generated by AITL Demo (Run ID: ${DEMO_REPO_NAME})*"

	log_info "Creating GitLab issue for ${jira_key}..."

	local result
	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would create GitLab issue: [${jira_key}] ${summary}"
		echo "999"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	# Use project ID if available (avoids redirect issues with recently recreated repos)
	if [[ -n "${GITLAB_PROJECT_ID:-}" ]]; then
		log_info "Using project ID: ${GITLAB_PROJECT_ID}"
		result=$(glab api "projects/${GITLAB_PROJECT_ID}/issues" -X POST \
			-f "title=[${jira_key}] ${summary}" \
			-f "description=${description}" \
			-f "labels=${labels}" \
			2>&1)

		if echo "${result}" | jq -e '.iid' >/dev/null 2>&1; then
			local issue_iid
			issue_iid=$(echo "${result}" | jq -r '.iid')
			local issue_url
			issue_url=$(echo "${result}" | jq -r '.web_url')
			log_ok "Created GitLab issue #${issue_iid}: ${issue_url}"

			# Verify GitLab issue exists
			echo -n "<verify> GitLab issue #${issue_iid} exists ... " >&2
			if glab api "projects/${GITLAB_PROJECT_ID}/issues/${issue_iid}" >/dev/null 2>&1; then
				echo "[V]" >&2
			else
				echo "[X]" >&2
				log_error "GitLab issue verification failed: #${issue_iid} not found" >&2
				return 1
			fi

			echo "${issue_iid}"
			return 0
		else
			log_error "Failed to create GitLab issue"
			echo "${result}" >&2
			return 1
		fi
	fi

	# Fallback to glab issue create (uses repo context)
	result=$(glab issue create \
		--title "[${jira_key}] ${summary}" \
		--description "${description}" \
		--label "${labels}" \
		2>&1)

	local issue_url
	issue_url=$(echo "${result}" | grep -oE 'https://[^[:space:]]+/issues/[0-9]+' | head -1)

	if [[ -z "${issue_url}" ]]; then
		log_error "Failed to create GitLab issue"
		echo "${result}" >&2
		return 1
	fi

	local issue_iid
	issue_iid=$(echo "${issue_url}" | grep -oE '[0-9]+$')

	log_ok "Created GitLab issue #${issue_iid}: ${issue_url}"

	# Verify GitLab issue exists
	echo -n "<verify> GitLab issue #${issue_iid} exists ... " >&2
	if glab issue view "${issue_iid}" >/dev/null 2>&1; then
		echo "[V]" >&2
	else
		echo "[X]" >&2
		log_error "GitLab issue verification failed: #${issue_iid} not found" >&2
		return 1
	fi

	echo "${issue_iid}"
}

# Create branch and push initial commit
# Args: $1=jira_key, $2=branch_type (feat|hotfix), $3=summary
# Returns: branch name via stdout
gitlab_branch_create_and_push() {
	local jira_key="$1"
	local branch_type="${2:-feat}"
	local summary="$3"

	if [[ -z "${jira_key}" ]]; then
		log_error "Usage: gitlab_branch_create_and_push <jira_key> [branch_type] [summary]"
		return 1
	fi

	# Generate branch name
	local slug
	if [[ -n "${summary}" ]]; then
		slug=$(echo "${summary}" | \
			tr '[:upper:]' '[:lower:]' | \
			tr ' ' '-' | \
			tr -cd '[:alnum:]-' | \
			cut -c1-30 | \
			sed 's/-$//')
	else
		slug="task"
	fi

	local branch_name="${branch_type}/${jira_key}-${DEMO_REPO_NAME}-${slug}"

	log_info "Creating branch: ${branch_name}"

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would create branch: ${branch_name}"
		log_info "[DRY-RUN] Would create worklog file and push"
		echo "${branch_name}"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	# Ensure we're on main/master
	local default_branch
	default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
	default_branch="${default_branch:-main}"

	git checkout "${default_branch}" >/dev/null 2>&1 || git checkout -b "${default_branch}" >/dev/null 2>&1
	git pull origin "${default_branch}" >/dev/null 2>&1 || true

	# Create branch
	if git checkout -b "${branch_name}" >/dev/null 2>&1; then
		log_ok "Branch created: ${branch_name}" >&2
	else
		log_warn "Branch may already exist, checking out..." >&2
		git checkout "${branch_name}" >/dev/null 2>&1 || return 1
	fi

	# Create worklog file as "trace" of work
	local worklog_dir="${DEMO_WORKSPACE}/worklog"
	mkdir -p "${worklog_dir}"

	local worklog_file="${worklog_dir}/${jira_key}.md"
	local timestamp
	timestamp=$(date '+%Y-%m-%d %H:%M:%S')

	cat > "${worklog_file}" <<EOF
# Work Log: ${jira_key}

## Summary
${summary:-Task work log}

## Timeline

- **Started**: ${timestamp}
- **Branch**: ${branch_name}
- **Run ID**: ${DEMO_REPO_NAME}

## Notes

This file was auto-generated by AITL Demo to track work on ${jira_key}.

---
*Generated at ${timestamp}*
EOF

	# Create minimal C artifact for sample comparison
	local src_dir="${DEMO_WORKSPACE}/src"
	mkdir -p "${src_dir}"
	local c_file="${src_dir}/${jira_key}.c"
	cat > "${c_file}" <<EOF
/*
 * ${jira_key}: ${summary:-Demo task}
 */

int ${jira_key//-/_}_placeholder(void) {
	return 0;
}
EOF

	# Commit and push
	log_info "Git add: ${worklog_file}, ${c_file}" >&2
	git add "${worklog_file}" "${c_file}" >&2

	log_info "Git commit for ${jira_key}..." >&2
	if ! git commit -m "${branch_type}: [${jira_key}] ${summary:-work in progress}

Jira: ${jira_key}
Run-ID: ${DEMO_REPO_NAME}" >&2; then
		log_error "Failed to commit changes" >&2
		git status >&2
		return 1
	fi
	log_ok "Commit successful" >&2

	# Show remote URL for debugging
	local remote_url
	remote_url=$(git remote get-url origin 2>/dev/null || echo "unknown")
	log_info "Git push to: ${remote_url}" >&2
	log_info "Branch: ${branch_name}" >&2

	local push_output
	if push_output=$(git push -u origin "${branch_name}" 2>&1); then
		log_ok "Branch pushed: ${branch_name}" >&2
	else
		log_error "Failed to push branch" >&2
		log_error "Remote URL: ${remote_url}" >&2
		log_error "Push output: ${push_output}" >&2
		return 1
	fi

	# Verify branch exists on remote
	echo -n "<verify> git ls-remote origin refs/heads/${branch_name} ... " >&2
	if git ls-remote --exit-code origin "refs/heads/${branch_name}" >/dev/null 2>&1; then
		echo "[V]" >&2
	else
		echo "[X]" >&2
		log_error "Branch verification failed: ${branch_name} not found on remote" >&2
		return 1
	fi

	echo "${branch_name}"
}

# Create Merge Request
# Args: $1=branch_name, $2=jira_key, $3=gitlab_issue_iid, $4=summary
# Returns: MR IID via stdout
gitlab_mr_create() {
	local branch_name="$1"
	local jira_key="$2"
	local gitlab_issue_iid="$3"
	local summary="$4"

	if [[ -z "${branch_name}" ]] || [[ -z "${jira_key}" ]]; then
		log_error "Usage: gitlab_mr_create <branch_name> <jira_key> [gitlab_issue_iid] [summary]"
		return 1
	fi

	local jira_url="${JIRA_BASE_URL}/browse/${jira_key}"

	local description="## Summary

${summary:-Work completed for ${jira_key}}

## Jira Link

- [${jira_key}](${jira_url})
"

	# Add GitLab issue close reference if provided
	if [[ -n "${gitlab_issue_iid}" ]]; then
		description+="
## Related Issues

Closes #${gitlab_issue_iid}
"
	fi

	description+="
---
*Auto-generated by AITL Demo (Run ID: ${DEMO_REPO_NAME})*"

	log_info "Creating MR for ${jira_key}..."

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would create MR: [${jira_key}] ${summary}"
		echo "999"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	local result

	# Get project ID if not set (required for reliable API calls)
	if [[ -z "${GITLAB_PROJECT_ID:-}" ]]; then
		log_info "GITLAB_PROJECT_ID not set, fetching from remote..." >&2
		local remote_url
		remote_url=$(git remote get-url origin 2>/dev/null || echo "")
		if [[ -n "${remote_url}" ]]; then
			# Extract project path from SSH URL: git@host:group/project.git -> group/project
			local project_path
			project_path=$(echo "${remote_url}" | sed -E 's#.*:(.*)\.git$#\1#')
			if [[ -n "${project_path}" ]]; then
				local encoded_path="${project_path//\//%2F}"
				local project_info
				project_info=$(glab api "projects/${encoded_path}" 2>/dev/null || echo "")
				if [[ -n "${project_info}" ]]; then
					GITLAB_PROJECT_ID=$(echo "${project_info}" | jq -r '.id // empty')
					if [[ -n "${GITLAB_PROJECT_ID}" ]]; then
						log_ok "Got project ID: ${GITLAB_PROJECT_ID}" >&2
					fi
				fi
			fi
		fi
	fi

	# Use project ID if available (avoids redirect issues with recently recreated repos)
	if [[ -n "${GITLAB_PROJECT_ID:-}" ]]; then
		log_info "Using project ID: ${GITLAB_PROJECT_ID}" >&2
		log_info "Source branch: '${branch_name}'" >&2
		result=$(glab api "projects/${GITLAB_PROJECT_ID}/merge_requests" -X POST \
			-f "title=[${jira_key}] ${summary:-Task completion}" \
			-f "description=${description}" \
			-f "source_branch=${branch_name}" \
			-f "target_branch=main" \
			-f "remove_source_branch=true" \
			2>&1)

		if echo "${result}" | jq -e '.iid' >/dev/null 2>&1; then
			local mr_iid
			mr_iid=$(echo "${result}" | jq -r '.iid')
			local mr_url
			mr_url=$(echo "${result}" | jq -r '.web_url')
			log_ok "Created MR !${mr_iid}: ${mr_url}"

			# Verify MR exists
			echo -n "<verify> glab mr view ${mr_iid} ... " >&2
			if glab api "projects/${GITLAB_PROJECT_ID}/merge_requests/${mr_iid}" >/dev/null 2>&1; then
				echo "[V]" >&2
			else
				echo "[X]" >&2
				log_error "MR verification failed: !${mr_iid} not found" >&2
				return 1
			fi

			echo "${mr_iid}"
			return 0
		else
			log_error "Failed to create MR via API" >&2
			log_error "API response: ${result}" >&2
			return 1
		fi
	fi

	# Fallback to glab mr create (uses repo context) - less reliable
	log_warn "Falling back to glab mr create (no project ID)" >&2
	result=$(glab mr create \
		--title "[${jira_key}] ${summary:-Task completion}" \
		--description "${description}" \
		--source-branch "${branch_name}" \
		--remove-source-branch \
		--yes \
		2>&1)

	local mr_url
	mr_url=$(echo "${result}" | grep -oE 'https://[^[:space:]]+/merge_requests/[0-9]+' | head -1)

	if [[ -z "${mr_url}" ]]; then
		log_error "Failed to create MR"
		echo "${result}" >&2
		return 1
	fi

	local mr_iid
	mr_iid=$(echo "${mr_url}" | grep -oE '[0-9]+$')

	log_ok "Created MR !${mr_iid}: ${mr_url}"

	# Verify MR exists
	echo -n "<verify> glab mr view ${mr_iid} ... " >&2
	if glab mr view "${mr_iid}" >/dev/null 2>&1; then
		echo "[V]" >&2
	else
		echo "[X]" >&2
		log_error "MR verification failed: !${mr_iid} not found" >&2
		return 1
	fi

	echo "${mr_iid}"
}

# Wait for MR to be merged (auto-merge attempt + HITL fallback)
# Args: $1=mr_iid, $2=hitl_enabled (true|false)
# Returns: 0 if merged, 1 if failed/cancelled
gitlab_mr_wait_merge() {
	local mr_iid="$1"
	local hitl_enabled="${2:-false}"
	local max_attempts="${3:-5}"

	if [[ -z "${mr_iid}" ]]; then
		log_error "Usage: gitlab_mr_wait_merge <mr_iid> [hitl_enabled] [max_attempts]"
		return 1
	fi

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would wait for MR !${mr_iid} to be merged"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	log_info "Checking MR !${mr_iid} status..."

	# Check current MR status
	local mr_status
	mr_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.state // "unknown"')

	if [[ "${mr_status}" == "merged" ]]; then
		log_ok "MR !${mr_iid} is already merged"
		return 0
	fi

	if [[ "${mr_status}" == "closed" ]]; then
		log_error "MR !${mr_iid} is closed (not merged)"
		return 1
	fi

	# Try auto-merge (skip pipeline check for demo repos without CI)
	log_info "Attempting to merge MR !${mr_iid}..."

	local attempt=1
	while [[ ${attempt} -le ${max_attempts} ]]; do
		log_info "Merge attempt ${attempt}/${max_attempts}..."

		# Try merge with --when-pipeline-succeeds=false to bypass CI check
		if glab mr merge "${mr_iid}" --yes --when-pipeline-succeeds=false 2>/dev/null; then
			log_ok "MR !${mr_iid} merged successfully"
			return 0
		fi

		# Fallback: try without the flag (older glab versions)
		if glab mr merge "${mr_iid}" --yes 2>/dev/null; then
			log_ok "MR !${mr_iid} merged successfully"
			return 0
		fi

		# Check if it needs approval or has other blockers
		local merge_status
		merge_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.detailed_merge_status // .merge_status // "unknown"')

		case "${merge_status}" in
			"mergeable"|"can_be_merged")
				# Should be mergeable, retry
				sleep 2
				;;
			"not_approved"|"need_approval"|"approvals_syncing")
				log_warn "MR requires approval"
				break
				;;
			"blocked_status"|"discussions_not_resolved")
				log_warn "MR has unresolved discussions or is blocked"
				break
				;;
			"checking"|"unchecked"|"ci_still_running"|"preparing")
				# GitLab is still checking MR status, wait and retry
				log_info "MR is being checked (${merge_status}), waiting..."
				sleep 5
				;;
			"commits_status"|"ci_must_pass")
				# CI check required but demo repos may not have CI configured
				# Try to merge via API directly with merge_when_pipeline_succeeds=false
				log_info "CI check pending (${merge_status}), attempting direct merge..."
				local mr_iid_num="${mr_iid}"
				local project_ref

				# Prefer project ID to avoid redirect issues
				if [[ -n "${GITLAB_PROJECT_ID:-}" ]]; then
					project_ref="${GITLAB_PROJECT_ID}"
				else
					project_ref=$(git remote get-url origin 2>/dev/null | sed -E 's#.*[:/](.+/.+)\.git#\1#' | sed 's#/#%2F#g')
				fi

				if [[ -n "${project_ref}" ]]; then
					if glab api "projects/${project_ref}/merge_requests/${mr_iid_num}/merge" -X PUT \
						-f "merge_when_pipeline_succeeds=false" \
						-f "should_remove_source_branch=true" 2>/dev/null | jq -e '.state == "merged"' >/dev/null 2>&1; then
						log_ok "MR !${mr_iid} merged via API"
						return 0
					fi
				fi
				sleep 3
				;;
			*)
				log_warn "MR status: ${merge_status}"
				sleep 3
				;;
		esac

		((attempt++))
	done

	# Auto-merge failed, try HITL if enabled
	if [[ "${hitl_enabled}" == "true" ]]; then
		local mr_url
		mr_url=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.web_url')

		log_warn "HITL: Auto-merge failed for MR !${mr_iid}"
		log_info "Please manually approve/merge the MR:"
		log_info "  ${mr_url}"
		echo ""
		log_info "Press Enter after merging the MR (or type 'skip' to skip)..."

		local response
		read -r response

		if [[ "${response}" == "skip" ]]; then
			log_warn "MR merge skipped by user"
			return 1
		fi

		# Verify merge
		mr_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.state // "unknown"')

		if [[ "${mr_status}" == "merged" ]]; then
			log_ok "MR !${mr_iid} confirmed merged"
			return 0
		else
			log_error "MR !${mr_iid} is still not merged (status: ${mr_status})"
			return 1
		fi
	fi

	log_error "Could not merge MR !${mr_iid}"
	return 1
}

# Check if MR is merged
# Args: $1=mr_iid
# Returns: 0 if merged, 1 if not
gitlab_mr_is_merged() {
	local mr_iid="$1"

	if [[ -z "${mr_iid}" ]]; then
		return 1
	fi

	if [[ "${DRY_RUN}" == "true" ]]; then
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	local mr_status
	mr_status=$(glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.state // "unknown"')

	[[ "${mr_status}" == "merged" ]]
}

# Get MR URL
# Args: $1=mr_iid
# Returns: MR URL via stdout
gitlab_mr_get_url() {
	local mr_iid="$1"

	if [[ -z "${mr_iid}" ]]; then
		return 1
	fi

	if [[ "${DRY_RUN}" == "true" ]]; then
		echo "https://gitlab.example.com/demo/merge_requests/${mr_iid}"
		return 0
	fi

	cd "${DEMO_WORKSPACE}" || return 1

	glab mr view "${mr_iid}" --output json 2>/dev/null | jq -r '.web_url'
}

# Add trace comment to Jira issue
# Args: $1=jira_key, $2=mr_url, $3=branch_name, $4=gitlab_issue_iid
jira_add_gitlab_trace() {
	local jira_key="$1"
	local mr_url="$2"
	local branch_name="$3"
	local gitlab_issue_iid="$4"

	if [[ -z "${jira_key}" ]]; then
		return 1
	fi

	# Construct comment text
	local comment="GitLab Integration (Run: ${DEMO_REPO_NAME})
- MR: ${mr_url:-N/A}
- Branch: ${branch_name:-N/A}
- GitLab Issue: #${gitlab_issue_iid:-N/A}
- Status: MR Merged"

	log_info "Adding GitLab trace comment to ${jira_key}..."

	if [[ "${DRY_RUN}" == "true" ]]; then
		log_info "[DRY-RUN] Would add comment to ${jira_key}"
		return 0
	fi

	local pm_cmd="${PM_CMD:-${PROJECT_ROOT}/tools/pm/bin/pm}"

	if ${pm_cmd} jira issue comment add "${jira_key}" "${comment}" 2>/dev/null; then
		log_ok "GitLab trace added to ${jira_key}"
		return 0
	else
		log_warn "Could not add GitLab trace comment to ${jira_key}"
		return 1
	fi
}

# Full GitLab flow: issue -> branch -> commit -> MR -> merge
# Args: $1=jira_key, $2=summary, $3=issue_type (feat|hotfix), $4=hitl_enabled
# Returns: 0 if successful (MR merged), 1 if failed
gitlab_full_flow() {
	local jira_key="$1"
	local summary="$2"
	local issue_type="${3:-feat}"
	local hitl_enabled="${4:-false}"

	if [[ -z "${jira_key}" ]]; then
		log_error "Usage: gitlab_full_flow <jira_key> [summary] [issue_type] [hitl_enabled]"
		return 1
	fi

	log_info "Starting GitLab flow for ${jira_key}..."

	# Step 1: Create GitLab issue
	local gitlab_issue_iid
	gitlab_issue_iid=$(gitlab_issue_create_for_jira "${jira_key}" "${summary}" "${issue_type}")

	if [[ -z "${gitlab_issue_iid}" ]]; then
		log_error "Failed to create GitLab issue"
		return 1
	fi

	# Step 2: Create branch and push
	local branch_name
	branch_name=$(gitlab_branch_create_and_push "${jira_key}" "${issue_type}" "${summary}")

	if [[ -z "${branch_name}" ]]; then
		log_error "Failed to create branch"
		return 1
	fi

	# Step 3: Create MR
	local mr_iid
	mr_iid=$(gitlab_mr_create "${branch_name}" "${jira_key}" "${gitlab_issue_iid}" "${summary}")

	if [[ -z "${mr_iid}" ]]; then
		log_error "Failed to create MR"
		return 1
	fi

	# Step 4: Wait for merge
	if gitlab_mr_wait_merge "${mr_iid}" "${hitl_enabled}"; then
		log_ok "GitLab flow completed for ${jira_key}"

		# Store MR info for later use
		GITLAB_LAST_MR_IID="${mr_iid}"
		GITLAB_LAST_MR_URL=$(gitlab_mr_get_url "${mr_iid}")
		GITLAB_LAST_ISSUE_IID="${gitlab_issue_iid}"
		GITLAB_LAST_BRANCH="${branch_name}"

		# Step 5: Add trace comment to Jira
		jira_add_gitlab_trace "${jira_key}" "${GITLAB_LAST_MR_URL}" "${branch_name}" "${gitlab_issue_iid}"

		return 0
	else
		log_warn "GitLab flow incomplete for ${jira_key} (MR not merged)"
		return 1
	fi
}

# Export functions
export -f gitlab_issue_create_for_jira
export -f gitlab_branch_create_and_push
export -f gitlab_mr_create
export -f gitlab_mr_wait_merge
export -f gitlab_mr_is_merged
export -f gitlab_mr_get_url
export -f gitlab_full_flow
export -f jira_add_gitlab_trace

# Export state variables
export GITLAB_LAST_MR_IID
export GITLAB_LAST_MR_URL
export GITLAB_LAST_ISSUE_IID
export GITLAB_LAST_BRANCH
