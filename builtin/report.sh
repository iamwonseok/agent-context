#!/bin/bash
# Agent-Context Report Command
# Generate diagnostic report
#
# Usage:
#   agent-context report [options]
#
# This script is sourced by bin/agent-context.sh

# ============================================================
# Usage
# ============================================================
report_usage() {
	cat <<EOF
Agent-Context Report

USAGE:
    agent-context report [options]

OPTIONS:
    --issue         Create GitLab issue with report (opt-in)
    --output FILE   Save report to file (default: stdout)
    --format FMT    Output format: markdown (default), json
    -v, --verbose   Include full logs
    -q, --quiet     Minimal output
    -h, --help      Show this help

DESCRIPTION:
    Generate a diagnostic report combining:
    - System information
    - Dependencies status
    - Authentication status
    - Project configuration
    - Recent errors

    The report is formatted in Markdown for easy sharing.

EXAMPLES:
    # Generate report to stdout
    agent-context report

    # Save to file
    agent-context report --output report.md

    # Create GitLab issue (requires glab)
    agent-context report --issue

EXIT CODES:
    0   Report generated successfully
    1   Report generation failed

EOF
}

# ============================================================
# Report Generator
# ============================================================

generate_report() {
	local verbose="$1"
	local format="$2"

	local ac_dir
	ac_dir=$(get_agent_context_dir)

	local project_root
	project_root=$(find_project_root "${PWD}" 2>/dev/null || true)

	cat <<EOF
# Agent-Context Diagnostic Report

Generated: $(date -Iseconds)

## System Information

| Item | Value |
|------|-------|
| OS | $(uname -s) $(uname -r) |
| Architecture | $(uname -m) |
| Shell | ${SHELL} |
| User | ${USER} |

## Agent-Context

| Item | Value |
|------|-------|
| Version | $(cat "${ac_dir}/VERSION" 2>/dev/null || echo "unknown") |
| Directory | ${ac_dir} |
| Git Branch | $(git -C "${ac_dir}" branch --show-current 2>/dev/null || echo "unknown") |
| Git Commit | $(git -C "${ac_dir}" rev-parse --short HEAD 2>/dev/null || echo "unknown") |

## Dependencies

| Command | Status | Version |
|---------|--------|---------|
EOF

	local deps=(git jq yq glab gh curl pre-commit shellcheck)
	for cmd in "${deps[@]}"; do
		local status="missing"
		local version="-"
		if has_cmd "${cmd}"; then
			status="installed"
			version=$(get_version "${cmd}" | head -1 | cut -c1-30)
		fi
		printf "| %s | %s | %s |\n" "${cmd}" "${status}" "${version}"
	done

	cat <<EOF

## Authentication

| Item | Status |
|------|--------|
EOF

	# Check secrets
	if [[ -d "${HOME}/.secrets" ]]; then
		local mode
		mode=$(stat -f "%OLp" "${HOME}/.secrets" 2>/dev/null || stat -c "%a" "${HOME}/.secrets" 2>/dev/null)
		echo "| ~/.secrets | exists (${mode}) |"
	else
		echo "| ~/.secrets | missing |"
	fi

	local tokens=("gitlab-api-token" "atlassian-api-token" "github-api-token")
	for token in "${tokens[@]}"; do
		if [[ -f "${HOME}/.secrets/${token}" ]]; then
			echo "| ${token} | exists |"
		else
			echo "| ${token} | missing |"
		fi
	done

	# glab auth
	if has_cmd glab; then
		if glab auth status 2>&1 | grep -q "Logged in"; then
			echo "| glab | authenticated |"
		else
			echo "| glab | not authenticated |"
		fi
	fi

	# Project info
	if [[ -n "${project_root}" ]]; then
		cat <<EOF

## Project

| Item | Value |
|------|-------|
| Root | ${project_root} |
| .cursorrules | $(test -f "${project_root}/.cursorrules" && echo "exists" || echo "missing") |
| .project.yaml | $(test -f "${project_root}/.project.yaml" && echo "exists" || echo "missing") |
| .agent/ | $(test -d "${project_root}/.agent" && echo "exists" || echo "missing") |
EOF

		# Check CHANGE_ME
		if [[ -f "${project_root}/.project.yaml" ]]; then
			local change_me
			change_me=$(grep -c "CHANGE_ME" "${project_root}/.project.yaml" 2>/dev/null || echo "0")
			echo "| CHANGE_ME count | ${change_me} |"
		fi
	else
		cat <<EOF

## Project

Not in a project directory.
EOF
	fi

	# Recent errors (if verbose)
	if [[ "${verbose}" == "true" ]]; then
		cat <<EOF

## Recent Errors

\`\`\`
EOF
		# Find recent error logs
		local log_dirs
		log_dirs=$(get_log_dirs "false" "false")
		for dir in ${log_dirs}; do
			if [[ -d "${dir}" ]]; then
				find "${dir}" -name "*.log" -type f -mtime -1 -exec grep -l '\[X\]' {} \; 2>/dev/null | \
				while read -r log_file; do
					echo "--- ${log_file} ---"
					grep '\[X\]' "${log_file}" | tail -5
				done
			fi
		done
		echo '```'
	fi

	cat <<EOF

---
*Report generated by agent-context report*
EOF
}

# ============================================================
# Main Report Function
# ============================================================
run_report() {
	local create_issue=false
	local output_file=""
	local format="markdown"
	local verbose=false
	local quiet=false

	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			--issue)
				create_issue=true
				;;
			--output|-o)
				output_file="$2"
				shift
				;;
			--format)
				format="$2"
				shift
				;;
			-v|--verbose)
				verbose=true
				;;
			-q|--quiet)
				quiet=true
				;;
			-h|--help)
				report_usage
				return 0
				;;
			*)
				log_error "Unknown option: $1"
				report_usage
				return 2
				;;
		esac
		shift
	done

	# Generate report
	local report
	report=$(generate_report "${verbose}" "${format}")

	# Output
	if [[ -n "${output_file}" ]]; then
		echo "${report}" > "${output_file}"
		log_ok "Report saved to: ${output_file}"
	elif [[ "${create_issue}" == "true" ]]; then
		# Create GitLab issue
		if ! has_cmd glab; then
			log_error "glab not installed (required for --issue)"
			return 1
		fi

		local project_root
		project_root=$(find_project_root "${PWD}" 2>/dev/null || true)

		if [[ -z "${project_root}" ]]; then
			log_error "Not in a project directory"
			return 1
		fi

		# Create issue
		log_progress "Creating GitLab issue..."
		local issue_title="Agent-Context Diagnostic Report - $(date +%Y-%m-%d)"
		local issue_url
		issue_url=$(echo "${report}" | glab issue create \
			--title "${issue_title}" \
			--description - \
			--label "diagnostic" 2>/dev/null)

		if [[ -n "${issue_url}" ]]; then
			log_ok "Issue created: ${issue_url}"
		else
			log_error "Failed to create issue"
			return 1
		fi
	else
		echo "${report}"
	fi

	return 0
}

# Allow direct execution for testing
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
	source "${SCRIPT_DIR}/lib/logging.sh"
	source "${SCRIPT_DIR}/lib/platform.sh"
	run_report "$@"
fi
