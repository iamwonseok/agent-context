#!/bin/bash
# Pipeline State Management (Intermediate Representation)
# Manages stage-to-stage data flow via .context/{task}/intermediate.yaml
#
# RFC-007: Architecture Pattern Improvements
# See: docs/rfcs/007-architecture-improvements.md

set -e

# ============================================================
# Constants
# ============================================================

PIPELINE_VERSION="1.0"
VALID_STAGES=("analyze" "planning" "execute" "validate" "integrate")

# ============================================================
# Helper Functions
# ============================================================

# Get context directory for a task
_get_context_dir() {
    local task_id="$1"
    local project_root="${PROJECT_ROOT:-.}"
    echo "${project_root}/.context/${task_id}"
}

# Get IR file path
_get_ir_file() {
    local task_id="$1"
    echo "$(_get_context_dir "$task_id")/intermediate.yaml"
}

# Check if yq is available
_require_yq() {
    if ! command -v yq &>/dev/null; then
        echo "[ERROR] yq is required. Install with: brew install yq" >&2
        return 1
    fi
}

# Validate stage name
_validate_stage() {
    local stage="$1"
    for valid in "${VALID_STAGES[@]}"; do
        if [[ "$stage" == "$valid" ]]; then
            return 0
        fi
    done
    echo "[ERROR] Invalid stage: $stage. Valid stages: ${VALID_STAGES[*]}" >&2
    return 1
}

# ============================================================
# Pipeline Functions
# ============================================================

# Initialize pipeline for a task
# Creates .context/{task}/intermediate.yaml
# Usage: pipeline_init <TASK_ID>
pipeline_init() {
    local task_id="$1"

    if [[ -z "$task_id" ]]; then
        echo "[ERROR] Task ID required" >&2
        return 1
    fi

    _require_yq || return 1

    local context_dir
    context_dir=$(_get_context_dir "$task_id")
    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    # Create context directory
    mkdir -p "$context_dir"

    # Create initial IR file
    cat > "$ir_file" << EOF
# Intermediate Representation (IR)
# Auto-generated by pipeline_init
# See RFC-007 for format specification

version: "${PIPELINE_VERSION}"
task_id: "${task_id}"
current_stage: null
created_at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
updated_at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

stages:
  analyze:
    completed: false
    timestamp: null
    outputs: null
  planning:
    completed: false
    timestamp: null
    outputs: null
  execute:
    completed: false
    timestamp: null
    outputs: null
  validate:
    completed: false
    timestamp: null
    outputs: null
  integrate:
    completed: false
    timestamp: null
    outputs: null
EOF

    echo "(v) Pipeline initialized: $ir_file"
}

# Get current stage
# Usage: pipeline_get_stage <TASK_ID>
pipeline_get_stage() {
    local task_id="$1"

    if [[ -z "$task_id" ]]; then
        echo "[ERROR] Task ID required" >&2
        return 1
    fi

    _require_yq || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        echo "[ERROR] Pipeline not initialized for task: $task_id" >&2
        return 1
    fi

    yq -r '.current_stage // "null"' "$ir_file"
}

# Set current stage
# Usage: pipeline_set_stage <TASK_ID> <STAGE>
pipeline_set_stage() {
    local task_id="$1"
    local stage="$2"

    if [[ -z "$task_id" ]] || [[ -z "$stage" ]]; then
        echo "[ERROR] Task ID and stage required" >&2
        return 1
    fi

    _require_yq || return 1
    _validate_stage "$stage" || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        echo "[ERROR] Pipeline not initialized for task: $task_id" >&2
        return 1
    fi

    yq -i ".current_stage = \"$stage\" | .updated_at = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" "$ir_file"
    echo "(v) Stage set to: $stage"
}

# Set output for a stage
# Usage: pipeline_set_output <TASK_ID> <STAGE> <KEY> <VALUE>
pipeline_set_output() {
    local task_id="$1"
    local stage="$2"
    local key="$3"
    local value="$4"

    if [[ -z "$task_id" ]] || [[ -z "$stage" ]] || [[ -z "$key" ]]; then
        echo "[ERROR] Task ID, stage, and key required" >&2
        return 1
    fi

    _require_yq || return 1
    _validate_stage "$stage" || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        echo "[ERROR] Pipeline not initialized for task: $task_id" >&2
        return 1
    fi

    # Initialize outputs object if null, then set the value
    local current_outputs
    current_outputs=$(yq -r ".stages.${stage}.outputs" "$ir_file")

    if [[ "$current_outputs" == "null" ]]; then
        yq -i ".stages.${stage}.outputs = {}" "$ir_file"
    fi

    # Set the output value
    yq -i ".stages.${stage}.outputs.${key} = \"${value}\" | .updated_at = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" "$ir_file"
    echo "(v) Output set: stages.${stage}.outputs.${key}"
}

# Get input from a stage (read output from previous stage)
# Usage: pipeline_get_input <TASK_ID> <STAGE> <KEY>
pipeline_get_input() {
    local task_id="$1"
    local stage="$2"
    local key="$3"

    if [[ -z "$task_id" ]] || [[ -z "$stage" ]] || [[ -z "$key" ]]; then
        echo "[ERROR] Task ID, stage, and key required" >&2
        return 1
    fi

    _require_yq || return 1
    _validate_stage "$stage" || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        echo "[ERROR] Pipeline not initialized for task: $task_id" >&2
        return 1
    fi

    yq -r ".stages.${stage}.outputs.${key} // \"\"" "$ir_file"
}

# Mark stage as complete
# Usage: pipeline_complete_stage <TASK_ID> <STAGE>
pipeline_complete_stage() {
    local task_id="$1"
    local stage="$2"

    if [[ -z "$task_id" ]] || [[ -z "$stage" ]]; then
        echo "[ERROR] Task ID and stage required" >&2
        return 1
    fi

    _require_yq || return 1
    _validate_stage "$stage" || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        echo "[ERROR] Pipeline not initialized for task: $task_id" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    yq -i ".stages.${stage}.completed = true | .stages.${stage}.timestamp = \"${timestamp}\" | .updated_at = \"${timestamp}\"" "$ir_file"
    echo "(v) Stage completed: $stage"
}

# Check if stage is complete
# Usage: pipeline_is_complete <TASK_ID> <STAGE>
# Returns: 0 if complete, 1 if not
pipeline_is_complete() {
    local task_id="$1"
    local stage="$2"

    if [[ -z "$task_id" ]] || [[ -z "$stage" ]]; then
        echo "[ERROR] Task ID and stage required" >&2
        return 1
    fi

    _require_yq || return 1
    _validate_stage "$stage" || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        return 1
    fi

    local completed
    completed=$(yq -r ".stages.${stage}.completed" "$ir_file")

    [[ "$completed" == "true" ]]
}

# Show pipeline status
# Usage: pipeline_status <TASK_ID>
pipeline_status() {
    local task_id="$1"

    if [[ -z "$task_id" ]]; then
        echo "[ERROR] Task ID required" >&2
        return 1
    fi

    _require_yq || return 1

    local ir_file
    ir_file=$(_get_ir_file "$task_id")

    if [[ ! -f "$ir_file" ]]; then
        echo "[ERROR] Pipeline not initialized for task: $task_id" >&2
        return 1
    fi

    echo "============================================================"
    echo "Pipeline Status: $task_id"
    echo "============================================================"
    echo "Version:       $(yq -r '.version' "$ir_file")"
    echo "Current Stage: $(yq -r '.current_stage // "not set"' "$ir_file")"
    echo "Created:       $(yq -r '.created_at' "$ir_file")"
    echo "Updated:       $(yq -r '.updated_at' "$ir_file")"
    echo "------------------------------------------------------------"
    echo "Stages:"

    for stage in "${VALID_STAGES[@]}"; do
        local completed
        completed=$(yq -r ".stages.${stage}.completed" "$ir_file" 2>/dev/null)
        local timestamp
        timestamp=$(yq -r ".stages.${stage}.timestamp" "$ir_file" 2>/dev/null)

        # Handle null values
        [[ "$timestamp" == "null" ]] && timestamp="-"

        local status_icon="[ ]"
        [[ "$completed" == "true" ]] && status_icon="[v]"

        printf "  %s %-12s %s\n" "$status_icon" "$stage" "$timestamp"
    done
    echo "============================================================"
}

# Clean up pipeline (remove context directory)
# Usage: pipeline_cleanup <TASK_ID>
pipeline_cleanup() {
    local task_id="$1"

    if [[ -z "$task_id" ]]; then
        echo "[ERROR] Task ID required" >&2
        return 1
    fi

    local context_dir
    context_dir=$(_get_context_dir "$task_id")

    if [[ -d "$context_dir" ]]; then
        rm -rf "$context_dir"
        echo "(v) Pipeline cleaned up: $task_id"
    else
        echo "[INFO] No context directory found for: $task_id"
    fi
}
