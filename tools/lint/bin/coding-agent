#!/usr/bin/env python3
"""
Ollama-based Autonomous Coding Agent

A local AI agent that can:
- Create feature branches
- Implement code changes with multiple commits
- Run tests and fix issues
- Push and create merge requests

Usage:
    coding-agent "Add login feature with 2FA support"
    coding-agent --interactive
"""

import argparse
import json
import os
import re
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Optional

import requests

# Configuration
OLLAMA_HOST = os.environ.get("OLLAMA_HOST", "http://localhost:11434")
OLLAMA_MODEL = os.environ.get("OLLAMA_MODEL", "qwen2.5-coder:14b")
GITLAB_URL = os.environ.get("GITLAB_URL", "")
GITLAB_TOKEN = os.environ.get("GITLAB_TOKEN", "")
MAX_ITERATIONS = 30
TIMEOUT_SECONDS = 300


@dataclass
class ToolResult:
    """Result from a tool execution"""
    success: bool
    output: str
    error: str = ""


class Tools:
    """Available tools for the agent"""

    def __init__(self, workspace: str):
        self.workspace = Path(workspace).resolve()
        os.chdir(self.workspace)

    def git_branch_create(self, branch_name: str) -> ToolResult:
        """Create and checkout a new git branch"""
        try:
            # Sanitize branch name
            safe_name = re.sub(r'[^a-zA-Z0-9_/-]', '-', branch_name)
            result = subprocess.run(
                ["git", "checkout", "-b", safe_name],
                capture_output=True, text=True, cwd=self.workspace
            )
            if result.returncode == 0:
                return ToolResult(True, f"Created and switched to branch: {safe_name}")
            return ToolResult(False, "", result.stderr)
        except Exception as e:
            return ToolResult(False, "", str(e))

    def git_commit(self, message: str) -> ToolResult:
        """Stage all changes and commit"""
        try:
            # Stage all changes
            subprocess.run(["git", "add", "-A"], cwd=self.workspace)

            # Check if there are changes to commit
            status = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True, text=True, cwd=self.workspace
            )
            if not status.stdout.strip():
                return ToolResult(True, "No changes to commit")

            # Commit
            result = subprocess.run(
                ["git", "commit", "-m", message],
                capture_output=True, text=True, cwd=self.workspace
            )
            if result.returncode == 0:
                return ToolResult(True, f"Committed: {message}")
            return ToolResult(False, "", result.stderr)
        except Exception as e:
            return ToolResult(False, "", str(e))

    def git_push(self, branch: str = "") -> ToolResult:
        """Push current branch to origin"""
        try:
            if not branch:
                # Get current branch name
                result = subprocess.run(
                    ["git", "branch", "--show-current"],
                    capture_output=True, text=True, cwd=self.workspace
                )
                branch = result.stdout.strip()

            result = subprocess.run(
                ["git", "push", "-u", "origin", branch],
                capture_output=True, text=True, cwd=self.workspace
            )
            if result.returncode == 0:
                return ToolResult(True, f"Pushed to origin/{branch}")
            return ToolResult(False, "", result.stderr)
        except Exception as e:
            return ToolResult(False, "", str(e))

    def git_status(self) -> ToolResult:
        """Get git status"""
        try:
            result = subprocess.run(
                ["git", "status", "--short"],
                capture_output=True, text=True, cwd=self.workspace
            )
            return ToolResult(True, result.stdout or "Working tree clean")
        except Exception as e:
            return ToolResult(False, "", str(e))

    def file_read(self, filepath: str) -> ToolResult:
        """Read a file"""
        try:
            full_path = self.workspace / filepath
            if not full_path.exists():
                return ToolResult(False, "", f"File not found: {filepath}")

            content = full_path.read_text()
            # Limit content size
            if len(content) > 10000:
                content = content[:10000] + "\n... (truncated)"
            return ToolResult(True, content)
        except Exception as e:
            return ToolResult(False, "", str(e))

    def file_write(self, filepath: str, content: str) -> ToolResult:
        """Write content to a file"""
        try:
            full_path = self.workspace / filepath
            full_path.parent.mkdir(parents=True, exist_ok=True)
            full_path.write_text(content)
            return ToolResult(True, f"Written to {filepath}")
        except Exception as e:
            return ToolResult(False, "", str(e))

    def file_edit(self, filepath: str, old_text: str, new_text: str) -> ToolResult:
        """Replace text in a file"""
        try:
            full_path = self.workspace / filepath
            if not full_path.exists():
                return ToolResult(False, "", f"File not found: {filepath}")

            content = full_path.read_text()
            if old_text not in content:
                return ToolResult(False, "", f"Text not found in {filepath}")

            new_content = content.replace(old_text, new_text, 1)
            full_path.write_text(new_content)
            return ToolResult(True, f"Edited {filepath}")
        except Exception as e:
            return ToolResult(False, "", str(e))

    def file_list(self, directory: str = ".") -> ToolResult:
        """List files in directory"""
        try:
            full_path = self.workspace / directory
            if not full_path.exists():
                return ToolResult(False, "", f"Directory not found: {directory}")

            files = []
            for item in sorted(full_path.iterdir()):
                if item.name.startswith('.'):
                    continue
                prefix = "[D] " if item.is_dir() else "[F] "
                files.append(f"{prefix}{item.name}")

            return ToolResult(True, "\n".join(files) if files else "Empty directory")
        except Exception as e:
            return ToolResult(False, "", str(e))

    def shell_run(self, command: str) -> ToolResult:
        """Run a shell command (with safety restrictions)"""
        # Safety: block dangerous commands
        dangerous = ["rm -rf", "sudo", "mkfs", "> /dev", "dd if="]
        for d in dangerous:
            if d in command:
                return ToolResult(False, "", f"Blocked dangerous command: {command}")

        try:
            result = subprocess.run(
                command, shell=True,
                capture_output=True, text=True,
                cwd=self.workspace, timeout=60
            )
            output = result.stdout
            if result.stderr:
                output += f"\nSTDERR: {result.stderr}"
            return ToolResult(result.returncode == 0, output, result.stderr if result.returncode != 0 else "")
        except subprocess.TimeoutExpired:
            return ToolResult(False, "", "Command timed out")
        except Exception as e:
            return ToolResult(False, "", str(e))

    def test_run(self, test_command: str = "") -> ToolResult:
        """Run tests"""
        if not test_command:
            # Auto-detect test command
            if (self.workspace / "pytest.ini").exists() or (self.workspace / "pyproject.toml").exists():
                test_command = "pytest -v"
            elif (self.workspace / "package.json").exists():
                test_command = "npm test"
            elif (self.workspace / "Makefile").exists():
                test_command = "make test"
            else:
                test_command = "echo 'No test command detected'"

        return self.shell_run(test_command)

    def search_code(self, pattern: str, file_pattern: str = "") -> ToolResult:
        """Search for code pattern using grep"""
        try:
            cmd = ["grep", "-rn", pattern, "."]
            if file_pattern:
                cmd = ["grep", "-rn", "--include", file_pattern, pattern, "."]

            result = subprocess.run(
                cmd, capture_output=True, text=True, cwd=self.workspace
            )
            output = result.stdout[:5000] if result.stdout else "No matches found"
            return ToolResult(True, output)
        except Exception as e:
            return ToolResult(False, "", str(e))

    def gitlab_create_mr(self, title: str, description: str, source_branch: str, target_branch: str = "main") -> ToolResult:
        """Create a GitLab merge request"""
        if not GITLAB_URL or not GITLAB_TOKEN:
            return ToolResult(False, "", "GitLab URL and TOKEN not configured")

        try:
            # Get project ID from git remote
            result = subprocess.run(
                ["git", "remote", "get-url", "origin"],
                capture_output=True, text=True, cwd=self.workspace
            )
            remote_url = result.stdout.strip()

            # Extract project path from URL
            match = re.search(r'[:/]([^/]+/[^/]+?)(?:\.git)?$', remote_url)
            if not match:
                return ToolResult(False, "", "Could not parse project path from remote URL")

            project_path = match.group(1).replace("/", "%2F")

            # Create MR via API
            api_url = f"{GITLAB_URL}/api/v4/projects/{project_path}/merge_requests"
            headers = {"PRIVATE-TOKEN": GITLAB_TOKEN}
            data = {
                "source_branch": source_branch,
                "target_branch": target_branch,
                "title": title,
                "description": description,
                "remove_source_branch": True
            }

            response = requests.post(api_url, headers=headers, json=data)
            if response.status_code == 201:
                mr_url = response.json().get("web_url", "")
                return ToolResult(True, f"Merge Request created: {mr_url}")
            return ToolResult(False, "", f"API error: {response.text}")
        except Exception as e:
            return ToolResult(False, "", str(e))


# Tool definitions for Ollama function calling
TOOL_DEFINITIONS = [
    {
        "type": "function",
        "function": {
            "name": "git_branch_create",
            "description": "Create and checkout a new git branch for the feature",
            "parameters": {
                "type": "object",
                "properties": {
                    "branch_name": {"type": "string", "description": "Branch name (e.g., feature/add-login)"}
                },
                "required": ["branch_name"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "git_commit",
            "description": "Stage all changes and create a commit",
            "parameters": {
                "type": "object",
                "properties": {
                    "message": {"type": "string", "description": "Commit message (conventional commit format)"}
                },
                "required": ["message"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "git_push",
            "description": "Push current branch to origin remote",
            "parameters": {
                "type": "object",
                "properties": {
                    "branch": {"type": "string", "description": "Branch name (optional, defaults to current)"}
                },
                "required": []
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "git_status",
            "description": "Get current git status",
            "parameters": {"type": "object", "properties": {}, "required": []}
        }
    },
    {
        "type": "function",
        "function": {
            "name": "file_read",
            "description": "Read contents of a file",
            "parameters": {
                "type": "object",
                "properties": {
                    "filepath": {"type": "string", "description": "Relative path to file"}
                },
                "required": ["filepath"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "file_write",
            "description": "Create or overwrite a file with content",
            "parameters": {
                "type": "object",
                "properties": {
                    "filepath": {"type": "string", "description": "Relative path to file"},
                    "content": {"type": "string", "description": "File content"}
                },
                "required": ["filepath", "content"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "file_edit",
            "description": "Replace specific text in a file",
            "parameters": {
                "type": "object",
                "properties": {
                    "filepath": {"type": "string", "description": "Relative path to file"},
                    "old_text": {"type": "string", "description": "Text to find and replace"},
                    "new_text": {"type": "string", "description": "Replacement text"}
                },
                "required": ["filepath", "old_text", "new_text"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "file_list",
            "description": "List files in a directory",
            "parameters": {
                "type": "object",
                "properties": {
                    "directory": {"type": "string", "description": "Directory path (default: current)"}
                },
                "required": []
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "shell_run",
            "description": "Run a shell command",
            "parameters": {
                "type": "object",
                "properties": {
                    "command": {"type": "string", "description": "Shell command to execute"}
                },
                "required": ["command"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "test_run",
            "description": "Run project tests",
            "parameters": {
                "type": "object",
                "properties": {
                    "test_command": {"type": "string", "description": "Test command (auto-detected if empty)"}
                },
                "required": []
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "search_code",
            "description": "Search for pattern in codebase",
            "parameters": {
                "type": "object",
                "properties": {
                    "pattern": {"type": "string", "description": "Search pattern (regex)"},
                    "file_pattern": {"type": "string", "description": "File glob pattern (e.g., *.py)"}
                },
                "required": ["pattern"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "gitlab_create_mr",
            "description": "Create a GitLab merge request",
            "parameters": {
                "type": "object",
                "properties": {
                    "title": {"type": "string", "description": "MR title"},
                    "description": {"type": "string", "description": "MR description"},
                    "source_branch": {"type": "string", "description": "Source branch name"},
                    "target_branch": {"type": "string", "description": "Target branch (default: main)"}
                },
                "required": ["title", "description", "source_branch"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "task_complete",
            "description": "Mark the task as complete and provide summary",
            "parameters": {
                "type": "object",
                "properties": {
                    "summary": {"type": "string", "description": "Summary of what was accomplished"}
                },
                "required": ["summary"]
            }
        }
    }
]


class CodingAgent:
    """Autonomous coding agent powered by Ollama"""

    def __init__(self, workspace: str):
        self.tools = Tools(workspace)
        self.messages = []
        self.iteration = 0

    def call_ollama(self, messages: list) -> dict:
        """Call Ollama API with tool support"""
        try:
            response = requests.post(
                f"{OLLAMA_HOST}/api/chat",
                json={
                    "model": OLLAMA_MODEL,
                    "messages": messages,
                    "tools": TOOL_DEFINITIONS,
                    "stream": False,
                    "options": {"temperature": 0.1, "num_ctx": 8192}
                },
                timeout=TIMEOUT_SECONDS
            )
            return response.json()
        except Exception as e:
            return {"error": str(e)}

    def execute_tool(self, tool_name: str, arguments: dict) -> str:
        """Execute a tool and return result"""
        tool_map = {
            "git_branch_create": lambda: self.tools.git_branch_create(arguments.get("branch_name", "")),
            "git_commit": lambda: self.tools.git_commit(arguments.get("message", "")),
            "git_push": lambda: self.tools.git_push(arguments.get("branch", "")),
            "git_status": lambda: self.tools.git_status(),
            "file_read": lambda: self.tools.file_read(arguments.get("filepath", "")),
            "file_write": lambda: self.tools.file_write(arguments.get("filepath", ""), arguments.get("content", "")),
            "file_edit": lambda: self.tools.file_edit(
                arguments.get("filepath", ""),
                arguments.get("old_text", ""),
                arguments.get("new_text", "")
            ),
            "file_list": lambda: self.tools.file_list(arguments.get("directory", ".")),
            "shell_run": lambda: self.tools.shell_run(arguments.get("command", "")),
            "test_run": lambda: self.tools.test_run(arguments.get("test_command", "")),
            "search_code": lambda: self.tools.search_code(
                arguments.get("pattern", ""),
                arguments.get("file_pattern", "")
            ),
            "gitlab_create_mr": lambda: self.tools.gitlab_create_mr(
                arguments.get("title", ""),
                arguments.get("description", ""),
                arguments.get("source_branch", ""),
                arguments.get("target_branch", "main")
            ),
        }

        if tool_name == "task_complete":
            return f"TASK_COMPLETE: {arguments.get('summary', '')}"

        if tool_name not in tool_map:
            return f"Unknown tool: {tool_name}"

        result = tool_map[tool_name]()
        if result.success:
            return f"(v) {result.output}"
        return f"(x) Error: {result.error}"

    def run(self, task: str) -> str:
        """Run the agent on a task"""
        print(f"\n{'='*60}")
        print(f"[INFO] Coding Agent Started")
        print(f"[TASK] {task}")
        print(f"[MODEL] {OLLAMA_MODEL}")
        print(f"{'='*60}\n")

        system_prompt = """You are an autonomous coding agent. Your job is to implement the requested feature by:

1. First, create a feature branch with a descriptive name
2. Explore the codebase to understand the structure
3. Implement the changes step by step
4. Create meaningful commits for each logical change
5. Run tests to verify your changes work
6. If tests fail, analyze and fix the issues
7. Push the branch and create a merge request

Always follow best practices:
- Use conventional commit messages (feat:, fix:, refactor:, etc.)
- Make small, focused commits
- Read existing code before modifying
- Run tests after significant changes

When you're done, call task_complete with a summary."""

        self.messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": task}
        ]

        while self.iteration < MAX_ITERATIONS:
            self.iteration += 1
            print(f"\n--- Iteration {self.iteration} ---")

            response = self.call_ollama(self.messages)

            if "error" in response:
                print(f"[ERROR] Ollama error: {response['error']}")
                break

            message = response.get("message", {})
            content = message.get("content", "")
            tool_calls = message.get("tool_calls", [])

            # Print agent's reasoning
            if content:
                print(f"\n[THINK] Agent: {content[:500]}...")

            # Process tool calls
            if tool_calls:
                self.messages.append(message)

                for tool_call in tool_calls:
                    func = tool_call.get("function", {})
                    tool_name = func.get("name", "")
                    arguments = func.get("arguments", {})

                    # Parse arguments if string
                    if isinstance(arguments, str):
                        try:
                            arguments = json.loads(arguments)
                        except:
                            arguments = {}

                    print(f"\n[TOOL] {tool_name}")
                    print(f"   Args: {json.dumps(arguments, indent=2)[:200]}")

                    result = self.execute_tool(tool_name, arguments)
                    print(f"   Result: {result[:300]}...")

                    # Check for task completion
                    if result.startswith("TASK_COMPLETE:"):
                        summary = result.replace("TASK_COMPLETE:", "").strip()
                        print(f"\n{'='*60}")
                        print(f"[DONE] Task Completed!")
                        print(f"[SUMMARY] {summary}")
                        print(f"{'='*60}\n")
                        return summary

                    # Add tool result to messages
                    self.messages.append({
                        "role": "tool",
                        "content": result
                    })
            else:
                # No tool calls, add response and continue
                if content:
                    self.messages.append(message)
                else:
                    print("[WARN] Empty response from model")
                    break

        print(f"\n[WARN] Max iterations ({MAX_ITERATIONS}) reached")
        return "Task incomplete - max iterations reached"


def check_ollama():
    """Check if Ollama is running"""
    try:
        response = requests.get(f"{OLLAMA_HOST}/api/tags", timeout=5)
        return response.status_code == 200
    except:
        return False


def main():
    global OLLAMA_MODEL

    parser = argparse.ArgumentParser(description="Ollama-based Coding Agent")
    parser.add_argument("task", nargs="?", help="Task description")
    parser.add_argument("--workspace", "-w", default=".", help="Workspace directory")
    parser.add_argument("--model", "-m", default=OLLAMA_MODEL, help="Ollama model to use")
    parser.add_argument("--interactive", "-i", action="store_true", help="Interactive mode")
    args = parser.parse_args()

    OLLAMA_MODEL = args.model

    if not check_ollama():
        print(f"[ERROR] Ollama is not running at {OLLAMA_HOST}")
        print("Start it with: docker-compose -f docker-compose.ollama.yml up -d")
        sys.exit(1)

    workspace = os.path.abspath(args.workspace)
    print(f"[WORKSPACE] {workspace}")

    if args.interactive:
        print("\n[INFO] Interactive Mode (type 'exit' to quit)\n")
        while True:
            try:
                task = input("[TASK] ").strip()
                if task.lower() in ["exit", "quit", "q"]:
                    break
                if task:
                    agent = CodingAgent(workspace)
                    agent.run(task)
            except KeyboardInterrupt:
                print("\n\nExiting...")
                break
    elif args.task:
        agent = CodingAgent(workspace)
        agent.run(args.task)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
