#!/usr/bin/env python3
"""
Ollama-based Commit Message Generator

An interactive tool that:
- Analyzes git changes (staged or unstaged)
- Generates commit messages using local LLM
- Allows user to accept, reject, or request regeneration with feedback

Usage:
    commit-agent              # Analyze staged changes
    commit-agent --all        # Stage all and analyze
    commit-agent --model qwen2.5-coder:14b
"""

import argparse
import json
import os
import subprocess
import sys
import urllib.request
import urllib.error
from typing import Optional

# Configuration
OLLAMA_HOST = os.environ.get("OLLAMA_HOST", "http://localhost:11434")
OLLAMA_MODEL = os.environ.get("OLLAMA_MODEL", "qwen2.5-coder:14b")
TIMEOUT_SECONDS = 120

# Colors for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RESET = '\033[0m'


def print_header(text: str):
    """Print a header"""
    print(f"\n{Colors.BOLD}{Colors.CYAN}{'='*60}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}{text}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}{'='*60}{Colors.RESET}\n")


def print_section(title: str, content: str):
    """Print a section with title"""
    print(f"{Colors.BOLD}{Colors.YELLOW}[{title}]{Colors.RESET}")
    print(content)
    print()


def print_commit_message(message: str):
    """Print the generated commit message in a nice box"""
    lines = message.strip().split('\n')
    max_len = max(len(line) for line in lines) if lines else 40
    max_len = max(max_len, 40)
    
    print(f"\n{Colors.GREEN}┌{'─' * (max_len + 2)}┐{Colors.RESET}")
    for line in lines:
        padding = ' ' * (max_len - len(line))
        print(f"{Colors.GREEN}│{Colors.RESET} {Colors.BOLD}{line}{padding} {Colors.GREEN}│{Colors.RESET}")
    print(f"{Colors.GREEN}└{'─' * (max_len + 2)}┘{Colors.RESET}\n")


def run_git_command(args: list[str]) -> tuple[bool, str]:
    """Run a git command and return (success, output)"""
    try:
        result = subprocess.run(
            ["git"] + args,
            capture_output=True,
            text=True,
            timeout=30
        )
        output = result.stdout + result.stderr
        return result.returncode == 0, output.strip()
    except subprocess.TimeoutExpired:
        return False, "Command timed out"
    except Exception as e:
        return False, str(e)


def get_git_status() -> str:
    """Get git status"""
    success, output = run_git_command(["status", "--short"])
    return output if success else ""


def get_staged_diff() -> str:
    """Get diff of staged changes"""
    success, output = run_git_command(["diff", "--cached", "--stat"])
    if not output:
        return ""
    
    # Also get the actual diff (limited)
    _, detailed = run_git_command(["diff", "--cached"])
    
    # Limit diff size for LLM context
    if len(detailed) > 8000:
        detailed = detailed[:8000] + "\n... (truncated)"
    
    return f"Summary:\n{output}\n\nDetailed changes:\n{detailed}"


def get_unstaged_diff() -> str:
    """Get diff of unstaged changes"""
    success, output = run_git_command(["diff", "--stat"])
    if not output:
        return ""
    
    _, detailed = run_git_command(["diff"])
    
    if len(detailed) > 8000:
        detailed = detailed[:8000] + "\n... (truncated)"
    
    return f"Summary:\n{output}\n\nDetailed changes:\n{detailed}"


def stage_all_changes():
    """Stage all changes"""
    return run_git_command(["add", "-A"])


def get_recent_commits(count: int = 10) -> str:
    """Get recent commit messages for style reference"""
    success, output = run_git_command([
        "log", f"-{count}", "--pretty=format:%s"
    ])
    return output if success else ""


def get_context_file(filepath: str) -> str:
    """Read a context file for commit convention reference"""
    try:
        from pathlib import Path
        path = Path(filepath)
        if path.exists():
            content = path.read_text()
            # Limit size
            if len(content) > 3000:
                content = content[:3000] + "\n... (truncated)"
            return content
    except Exception:
        pass
    return ""


def find_convention_file() -> str:
    """Auto-detect convention files in the project"""
    candidates = [
        ".cursorrules",
        "CONTRIBUTING.md",
        ".github/CONTRIBUTING.md",
        "docs/CONTRIBUTING.md",
        "COMMIT_CONVENTION.md",
    ]
    from pathlib import Path
    for candidate in candidates:
        if Path(candidate).exists():
            return candidate
    return ""


def commit_changes(message: str) -> tuple[bool, str]:
    """Create a commit with the given message"""
    return run_git_command(["commit", "-m", message])


def check_ollama() -> bool:
    """Check if Ollama is running"""
    try:
        req = urllib.request.Request(f"{OLLAMA_HOST}/api/tags")
        with urllib.request.urlopen(req, timeout=5) as response:
            return response.status == 200
    except:
        return False


def generate_commit_message(
    diff: str,
    feedback: str = "",
    previous_message: str = "",
    recent_commits: str = "",
    context_content: str = ""
) -> Optional[str]:
    """Generate commit message using Ollama"""
    
    system_prompt = """You are a commit message generator. Analyze the git diff and generate a clear, concise commit message.

Follow these rules:
1. Use conventional commit format: type(scope): description
2. Types: feat, fix, refactor, docs, style, test, chore, perf, ci, build
3. Keep the first line under 72 characters
4. If needed, add a blank line and then a body with more details
5. Focus on WHAT changed and WHY, not HOW
6. For scope, use module/feature names (e.g., cli, api, auth) NOT file paths

Example formats:
- feat(cli): add interactive commit message generator
- fix(api): resolve null pointer in user endpoint
- refactor(core): simplify error handling logic
- docs(readme): update installation instructions

Output ONLY the commit message, nothing else."""

    # Add project-specific context
    if recent_commits:
        system_prompt += f"""

IMPORTANT: Follow this project's commit style. Recent commits in this project:
{recent_commits}

Match the style, scope naming convention, and tone of these existing commits."""

    if context_content:
        system_prompt += f"""

Project-specific conventions:
{context_content}"""

    user_content = f"Git diff:\n```\n{diff}\n```"
    
    if previous_message and feedback:
        user_content += f"\n\nPrevious message:\n```\n{previous_message}\n```"
        user_content += f"\n\nUser feedback: {feedback}"
        user_content += "\n\nPlease regenerate the commit message based on this feedback."
    
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_content}
    ]
    
    try:
        print(f"{Colors.DIM}Generating commit message...{Colors.RESET}", end="", flush=True)
        
        data = json.dumps({
            "model": OLLAMA_MODEL,
            "messages": messages,
            "stream": False,
            "options": {"temperature": 0.3, "num_ctx": 8192}
        }).encode("utf-8")
        
        req = urllib.request.Request(
            f"{OLLAMA_HOST}/api/chat",
            data=data,
            headers={"Content-Type": "application/json"},
            method="POST"
        )
        
        with urllib.request.urlopen(req, timeout=TIMEOUT_SECONDS) as response:
            print(f"\r{' ' * 40}\r", end="")  # Clear the loading message
            
            if response.status == 200:
                result = json.loads(response.read().decode("utf-8"))
                return result.get("message", {}).get("content", "").strip()
            else:
                print(f"{Colors.RED}Error: API returned {response.status}{Colors.RESET}")
                return None
            
    except urllib.error.URLError as e:
        print(f"\n{Colors.RED}Error: {e.reason}{Colors.RESET}")
        return None
    except TimeoutError:
        print(f"\n{Colors.RED}Error: Request timed out{Colors.RESET}")
        return None
    except Exception as e:
        print(f"\n{Colors.RED}Error: {e}{Colors.RESET}")
        return None


def interactive_loop(diff: str, recent_commits: str = "", context_content: str = "") -> bool:
    """Interactive loop for commit message generation"""
    feedback = ""
    previous_message = ""
    
    while True:
        # Generate commit message
        message = generate_commit_message(
            diff, feedback, previous_message, recent_commits, context_content
        )
        
        if not message:
            print(f"{Colors.RED}Failed to generate commit message{Colors.RESET}")
            return False
        
        # Display the generated message
        print_section("Generated Commit Message", "")
        print_commit_message(message)
        
        # Show options
        print(f"{Colors.BOLD}Options:{Colors.RESET}")
        print(f"  {Colors.GREEN}y{Colors.RESET} - Accept and commit")
        print(f"  {Colors.RED}n{Colors.RESET} - Cancel")
        print(f"  {Colors.YELLOW}<text>{Colors.RESET} - Enter feedback to regenerate")
        print()
        
        try:
            user_input = input(f"{Colors.BOLD}Your choice: {Colors.RESET}").strip()
        except (KeyboardInterrupt, EOFError):
            print(f"\n{Colors.YELLOW}Cancelled{Colors.RESET}")
            return False
        
        if user_input.lower() == 'y':
            # Commit with the message
            success, output = commit_changes(message)
            if success:
                print(f"\n{Colors.GREEN}(v) Committed successfully!{Colors.RESET}")
                print(f"{Colors.DIM}{output}{Colors.RESET}")
                return True
            else:
                print(f"\n{Colors.RED}(x) Commit failed: {output}{Colors.RESET}")
                return False
                
        elif user_input.lower() == 'n':
            print(f"{Colors.YELLOW}Cancelled{Colors.RESET}")
            return False
            
        elif user_input:
            # Use input as feedback for regeneration
            feedback = user_input
            previous_message = message
            print(f"\n{Colors.CYAN}Regenerating with feedback: {feedback}{Colors.RESET}\n")
            
        else:
            # Empty input, show options again
            print(f"{Colors.YELLOW}Please enter y, n, or your feedback{Colors.RESET}\n")


def main():
    global OLLAMA_MODEL
    
    parser = argparse.ArgumentParser(
        description="Generate commit messages using Ollama",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    commit-agent              # Analyze staged changes
    commit-agent --all        # Stage all changes first
    commit-agent -m gemma2    # Use different model

Environment variables:
    OLLAMA_HOST    Ollama API URL (default: http://localhost:11434)
    OLLAMA_MODEL   Model to use (default: qwen2.5-coder:14b)
"""
    )
    parser.add_argument("--all", "-a", action="store_true",
                        help="Stage all changes before analyzing")
    parser.add_argument("--model", "-m", default=OLLAMA_MODEL,
                        help="Ollama model to use")
    parser.add_argument("--dry-run", "-d", action="store_true",
                        help="Only show diff, don't generate message")
    parser.add_argument("--context", "-c", default="",
                        help="Path to convention file (auto-detected if not specified)")
    parser.add_argument("--no-history", action="store_true",
                        help="Don't use git history for style reference")
    args = parser.parse_args()
    
    OLLAMA_MODEL = args.model
    
    # Check Ollama
    if not check_ollama():
        print(f"{Colors.RED}(x) Ollama is not running at {OLLAMA_HOST}{Colors.RESET}")
        print(f"  Start it with: ollama serve")
        print(f"  Or set OLLAMA_HOST environment variable")
        sys.exit(1)

    print_header("Commit Agent")
    print(f"{Colors.DIM}Model: {OLLAMA_MODEL}{Colors.RESET}")
    
    # Get git status
    status = get_git_status()
    if not status:
        print(f"{Colors.YELLOW}No changes detected{Colors.RESET}")
        sys.exit(0)
    
    print_section("Git Status", status)
    
    # Stage all if requested
    if args.all:
        print(f"{Colors.CYAN}Staging all changes...{Colors.RESET}")
        success, _ = stage_all_changes()
        if not success:
            print(f"{Colors.RED}Failed to stage changes{Colors.RESET}")
            sys.exit(1)
    
    # Get staged diff
    diff = get_staged_diff()
    
    if not diff:
        # No staged changes, show unstaged
        unstaged = get_unstaged_diff()
        if unstaged:
            print(f"{Colors.YELLOW}No staged changes. Found unstaged changes:{Colors.RESET}")
            print_section("Unstaged Changes", unstaged[:2000])
            print(f"\n{Colors.CYAN}Tip: Use 'commit-agent --all' to stage all changes{Colors.RESET}")
            print(f"{Colors.CYAN}     Or 'git add <files>' to stage specific files{Colors.RESET}")
        else:
            print(f"{Colors.YELLOW}No changes to commit{Colors.RESET}")
        sys.exit(0)
    
    print_section("Changes to Commit", diff[:2000] + ("..." if len(diff) > 2000 else ""))
    
    if args.dry_run:
        print(f"{Colors.YELLOW}Dry run mode - not generating message{Colors.RESET}")
        sys.exit(0)
    
    # Get recent commits for style reference
    recent_commits = ""
    if not args.no_history:
        recent_commits = get_recent_commits(10)
        if recent_commits:
            print(f"{Colors.DIM}Using {len(recent_commits.splitlines())} recent commits for style reference{Colors.RESET}")
    
    # Get context file
    context_content = ""
    context_file = args.context or find_convention_file()
    if context_file:
        context_content = get_context_file(context_file)
        if context_content:
            print(f"{Colors.DIM}Using convention file: {context_file}{Colors.RESET}")
    
    print()
    
    # Run interactive loop
    success = interactive_loop(diff, recent_commits, context_content)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
